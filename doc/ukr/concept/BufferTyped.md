# <code>BufferTyped</code> буфери

Стандартні типізовані буфери, котрі представляють двійкові дані у вигляді числових форматів.

[Тип `BufferTyped`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) - тип буфера, що представляє бінарні дані у вигляді загальноприйнятих числових форматів таких як  `Int8`, `Uint32`, `Float64` та інших. Таким чином, одна і та ж послідовність байтів буферу, може представлятись в різних форматах. Доступ до елементів буферу здійснюється за індексом.

Типізовані буфери можуть створюватись як незалежні об'єкти, а також використовуватись для представлення даних в `BufferRaw` буфері.

Перелік типізованих буферів:

- `I8x` ( `Int8Array` );
- `U8x` ( `Uint8Array` );
- `U8ClampedX` ( `Uint8ClampedArray` );
- `I16x` ( `Int16Array` );
- `U16x` ( `Uint16Array` );
- `I32x`, аналогічна назва `Ix` ( `Int32Array` );
- `U32x`, аналогічна назва `Ux` ( `Uint32Array` );
- `F32x`, аналогічна назва `Fx` ( `Float32Array` );
- `F64x` ( `Float64Array` );
- `I64x` ( `BigInt64Array` );
- `U64x` ( `BigInt64Array` ).

### Приклади

```js
var uint8 = new U8x();
console.log( uint8.length ) // log 0
console.log( uint8.byteLength ) // log 0
```

Для створення екземпляру типізованого буфера потрібно викликати конструктор відповідного класу та передати аргумент для створення буферу. Якщо конструктор викликати без аргументів, тоді буде створено порожній типізований буфер.
Змінній `uint8` присвоєно буфер `U8x`. Оскільки конструктор викликано без аргументів його довжина рівна нулю.

```js
var int8 = new I8x( 20 );
console.log( int8.length ); // log 20
console.log( int8.byteLength ); // log 20
```

У випадку передачі довжини буферу, створюється типізований буфер з заданою кількістю елементів. Оскільки числовий тип `Int8` представляє собою однобайтові числа зі знаком, то розмір відповідає довжині буферу.

```js
var int16 = new I16x( [ 1, 2, 10 ] );
console.log( int16.length ); // log 3
console.log( int16.byteLength ); // log 6
```

При передачі масиву з даними, конструктор створює типізований буфер рівний довжині переданого буферу. Кожен елемент масиву перетворюєтся до типу і розміру вказаного в конструкторі. Для буферу `int16` кожен елемент вхідного масиву перетворено в число зі знаком розміром по два байта.

```js
var raw = new BufferRaw( 32 );

var float32 = new F32x( raw );
console.log( float32.length ); // log 8
console.log( float32.byteLength ); // log 32

var uint64 = new U64x( raw );
console.log( uint64.length ); // log 4
console.log( uint64.byteLength ); // log 32
```

При створенні представлення `raw` буферу з допомогою типізованого, послідовність байтів `raw` буферу ділиться на частини згідно розміру елементу типізованого буфера. Таким чином, типізований буфер `float32` має 8 елементів. А при використанні представлення в `uint64` типізований буфер має вдвічі меншу довжину тому, що розмір одного елемента типу `U64x` складає вісім однобайтних чисел.

При створенні типізованого буферу з `raw` буфера, фактично, типізованому буферу передається посилання на `raw` буфер. Копіювання `raw` буферу не проходить тому, при зміні представлення в типізованому буфері `raw` буфер змінюється також.

```js
var raw = new BufferRaw( 32 );

var uint8First = new U8x( raw );
var uint8Second = new U8x( raw );

uint8First[ 0 ] = 20;
uint8Second[ 5 ] = 3;

console.log( uint8First[ 5 ] ); // log 3
console.log( uint8Second[ 0 ] ); // log 20
```

Для доступу до окремих елементів типізованого буферу використовуються індекси, як в звичайному масиві. В приведеному прикладі з `BufferRaw` буферу створено два представлення - `uint8First` i `uint8Second`. Зміна значень в одному з буферів відобразилась в іншому.

### Підсумок

- Типізовані буфери представляють двійкові дані у вигляді поширених числових форматів.
- Доступ до елементів типізованих буферів здійснюється за індексом.
- Довжина типізованого буферу визначається кількістю елементів.
- Типізовані буфери можуть використовуватись самостіно або бути представленням `BufferRaw` буферу.
- При створенні представлення з `BufferRaw` фактично передається посилання на оригінальний буфер. Тому зміна даних в одному з представлень відображається в інших.

[Повернутись до змісту](../README.md#Концепції)

