# Як заміряти продуктивність алгоритму ( performance )

Замір показників продуктивності для вибору оптимального алгоритму.

Будь-яка задача може мати більш ніж один варіант рішення. Кожен з представлених алгоритмів має свої переваги і недоліки, а тому потребує обґрунтованого вибору. Серед показників, за якими віддають перевагу одним рішенням перед іншими є зменшений об'єм використаної оперативної пам'яті, а також час виконання алгоритмом певного об'єму роботи. Тож, визначимо, як оцінити час виконання алгоритмом певного об'єму роботи, іншими словами, продуктивність алгоритму ( performance ).

### Особливості замірів продуктивності алгоритму

Головним правилом тестування продуктивності алгоритму є достовірність отриманих даних. Для того, щоб забезпечити достовірність даних потрібно дотримуватись наступних правил:

- Окремі алгоритми повинні мати окремі реалізації.
- Доступ до окремих алгоритмів повинен бути однаковим.
- Генерація даних і замір продуктивності алгоритму два різних етапи, тому їх виконання має бути розділене в часі.
- Тестування повинні проводитись на одній машині. Якщо використовується декілька машин для тестування, то на кожній з них проводиться повний цикл тестування. При цьому аналізується загальна тенденція, відносні величини, а не конкретні заміри.
- При проведенні тестування необхідно обмежити вплив випадкових факторів - наприклад, відкласти заплановані в операційній системі задачі на період тестування, вимкнути зайві процеси і задачі.
- Для підтвердження отриманих даних потрібно здійснити щонайменше 5 замірів часу на кожному алгоритмі, що дозволить знайти середній час проходження і дасть змогу відслідкувати вплив випадкових факторів.
- Об'єм роботи, котрий виконує алгоритм повинен бути достатнім для того, щоб заміри часу мали не випадковий характер. Бажаний час одного експерименту для простих рутини має бути біля 10с або більше.

### Етапи тестування продуктивності алгоритму

В загальному процедура виглядає наступним чином

- Підготовка даних для тестування.
- Замір часу початку тестування.
- Процес виконання алгоритму.
- Замір часу завершення тестування.

### Тестування продуктивності ітеративних алгоритмів інтерпретатора NodeJS

<details>
  <summary><u>Структура файлів</u></summary>

```
performance
    ├── PerformanceTesting.js
    └── package.json
```

</details>

Створіть приведену вище структуру файлів для визначення продуктивності ітеративних алгоритмів NodeJS.

<details>
    <summary><u>Код файла <code>PerformanceTesting.js</code></u></summary>

```js
let _ = require( 'wTools' );

/* */

var srcArray = new U8x( 500000000 );

testTime( entityEachLongsFor, 20, srcArray, onEach );
// testTime( entityEachLongsForEach, 20, srcArray, onEach );

/* */

function testTime( func, times, data, callback )
{
  var timeStart = _.time.now();
  for( let i = times; i > 0; i-- )
  var result = func( data, callback );
  var spentTime = _.time.spent( timeStart );
  console.log( spentTime );
}

var onEach = ( e, k, src ) => e;

function entityEachLongsFor( src, onEach )
{
  for( let k = 0 ; k < src.length ; k++ )
  onEach( src[ k ], k, src );
  return src
}

function entityEachLongsForEach( src, onEach )
{
  src.forEach( onEach );
  return src;
}
```

</details>

В файл `Performance.js` внесіть код приведений вище.

В тест файлі порівнюється швидкість виконання циклу `for` i методу `forEach` при переборі елементів масивів і типізованих масивів.

#### Підготовка даних

В даному випадку створюється ініціалізований типізований масив однобайтних цілих чисел

```js
var srcArray = new U8x( 500000000 );
```
Після генерації типізований масив `srcArray` доступний перебору даних.

#### Тестування алгоритмів

Для тестування окремих алгоритмів була створена рутина `testTime`, що приймає 4 параметри.

- `func` - рутина котра реалізує певний алгоритм.
- `times` - повторний запуск алгоритму `times` разів. Збільшує час виконання алгоритму для забезпечення достовірності даних, та дозволяє використовувати менший об'єм згенерованих даних.
- `data` - дані для алгоритму.
- `callback` - колбек для алгоритму.

Рутина `testTime` перед початком заміряє поточний час з допомогою рутини `_.time.now()`

```js
var timeStart = _.time.now();
```

а після виконання визначає використаний час

```js
var spentTime = _.time.spent( timeStart );
```

Після чого виводить дані в консоль.

В приведеному коді

```js
testTime( entityEachLongsFor, 20, srcArray, onEach );
// testTime( entityEachLongsForEach, 20, srcArray, onEach );
```

одна рутина закоментована для того, щоб не впливати на час виконання іншої. Після проведення дослідів з однією рутиною потрібно закоментувати першу і розкоментувати другу.

### Результати замірів для NodeJS v10

| Цикл for | Метод forEach |
| -------- | ------------- |
| 12,8 s   | 137,1 s       |
| 13,0 s   | 137,8 s       |
| 12,9 s   | 138,8 s       |
| 12,5 s   | 137,9 s       |
| 13,1 s   | 138,5 s       |

Проведене тестування показує, що вбудований метод `forEach` працює до 10 разів довше від циклу `for`. На основі цього можна сказати, що для збільшення швидкодії програми при переборі елементів масивів краще використовувати цикл `for`, а не вбудований метод `forEach`.

### Підсумок

- Вибір конкретного алгоритму для вирішення задачі залежить від поставлених умов. В загальному випадку орієнтуються на об'єм використаної оперативної пам'яті і на час виконання алгоритму.
- Найважливішим показником при тестування продуктивності алгоритму є достовірність отриманих даних.
- Для забезпечення достовірності даних з тестування потрібно виключити влив випадкових факторів.
- Для визначення характеристики алгоритму необхідно не менше ніж 5 замірів часу.
- Тривалість одного експерименту повинна бути такою, щоб виключити можливість значних похибок.
- Генерація даних повинна проходити окремо від тестування продуктивності алгоритму.
- Кожен алгоритм тестується окремо.

[Повернутись до змісту](../README.md#Туторіали)
