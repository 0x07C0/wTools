# Як заміряти час

Замір часу виконання алгоритмів для вибору оптимального рішення.

Проблема може мати більше одного рішення і замір часу виконання є інструментом для вибору найкращого рішення.

### Замір часу

Перед початком виконання алгоритму замірте поточний час за допомогою рутини `_.time.now()` чи альтернативно `Date.now()`.

``` js
var time = _.time.now();
```

Результат збережіть в змінну чи константу. Після виконання алгоритму отримайте різницю часу за допомогою рутини `_.time.spent`.

```js
_.time.spent( time );
```

Альтернативно можливо повторно викликати `_.time.now()` і знайти різницю між двома замірами, але при цьому доведеться робити трансформування одиниць вимірювання часу вручну.

### Приклад

Для демонстрації техніки заміру часу створіть файл `Performance.js` із таким вмістом.

<details>
<summary><u>Код файла <code>Performance.js</code></u></summary>

``` js
let _ = require( 'wTools' );
let times = 400;
let size = 500000;
let array = new U8x( size );

var counter = 0;
var time = _.time.now();
for( let i = times ; i > 0; i-- )
var result = forLoop( array, () => counter += 1 );
console.log( `For loop took ${_.time.spent( time )} on Njs ${process.version}` );
console.info( `Output ${counter} to avoid unwanted optimization` );

var counter = 0;
var time = _.time.now();
for( let i = times ; i > 0; i-- )
var result = forEach( array, () => counter += 1 );
console.log( `For each took ${_.time.spent( time )} on Njs ${process.version}` );
console.info( `Output ${counter} to avoid unwanted optimization` );

function forLoop( src, onEach )
{
  for( let k = 0 ; k < src.length ; k++ )
  onEach( src[ k ], k, src );
  return src
}

function forEach( src, onEach )
{
  src.forEach( ( e, k, src ) => onEach( e, k, src ) );
  return src;
}

```

</details>

Код приведений вище має 2-ві реалізації ітерування елементів масиву: `forLoop` та `forEach`. В програмі заміряється час потрібен для перебору елементів масиву довжиною 500000 елементів. Для того щоб мінімізувати похибку, яка вноситься динамічність середовища обхід здійснюється по 100 разів обома способами.

### Результати замірів

Результати тестування слід зібрати в табличку із вказанням інтерпретатора та її версії. Результати можуть суттєво відрізнятися від інтерпретатора до інтерпретатора, від версії до версії.

| sda          | forLoop | forEach |
|--------------|---------|---------|
| Njs v10.16.0 | 4.240 s | 7.195 s |
|              | 4.240 s | 7.086 s |
|              | 4.229 s | 7.183 s |
|              | 4.216 s | 7.130 s |
|              | 4.221 s | 7.214 s |
| Njs v11.3.0  | 4.359 s | 7.212 s |
|              | 4.411 s | 7.286 s |
|              | 4.425 s | 7.286 s |
|              | 4.319 s | 7.249 s |
|              | 4.344 s | 7.259 s |
| Njs v12.7.0  | 4.982 s | 8.850 s |
|              | 4.984 s | 8.950 s |
|              | 5.997 s | 8.827 s |
|              | 5.006 s | 8.665 s |
|              | 4.995 s | 8.914 s |

Звіт показує, що цикл `for` працює в 2 рази швидше за цикл `forEach`. На основі цього має бути рекомендація використати 1-ий варіант реалізації алгоритму.

### Достовірність та помилки

Достовірність результатів тестування гарантувати не просто проте можливо уникнути деяких часто повторюваних помилок. Результати заміру часу є достовірними якщо по ним можливо робити прогнози по швидкодійності алгоритму.

Для високої договірності потрібно мінімізувати вплив середовища. Важкі задачі, що виконуються в фоні на вашій машині можуть суттєво спотворити результат. Результати не можна порівнювати якщо вони були отримані за різних умов. Якщо змінюється середовище то і результат змінюється. Не можна порівнювати результати отримані на різних машинах. І як би ви не старалися все одно є вплив випадку і неконтрольовані фактори тому замір потрібно робити декілька разів і брати середнє або сумарне значення.

Замір не може бути достовірним якщо проміжок часу який замірюється всього мілісекунда. Правило пальця: проміжок має бути не менше одної секунди.

Інша помилка, яку можна допустити при замірі це включання часу генерації тестових даних. Генерація тестових займає час. Дані треба підготувати до початку заміру часу і використати, коли вони будуть потрібні.

Оптимізація інтерпретатором ще один підводний камінь. Інтерпретатор може викинути частину коду, якщо помітить, що він не використовує. Тому алгоритм який тестується повинен мати коректні аргументи, а результат виконання має якось використовуватися.

### Підсумок

- Час можливо замірити за допомогою пари рутин `_.time.now` та `_.time.spent`.
- Для забезпечення достовірності результатів потрібно мінімізувати влив середовища.
- Проганяйте експеримент декілька разів й використовуйте середній або сумарний час щоб мінімізувати похибку.
- Тривалість одного експерименту повинна бути такою, щоб виключити можливість значних похибок.
- Генерація даних повинна проходити окремо від тестування продуктивності алгоритму.
- Динамічність середовища виконання вносить похибку в замір часу тому алгоритм слід проганяти декілька разів щоб отримати середнє значення.
- Вплив динамічного середовище варто мінімізувати: однакове завантаження, однакові версії, одна машина.
- Продуктивність виконання алгоритму одним інтерпретатором може відрізнятися від продуктивності виконання алгоритму іншим інтерпретатором. Звіт про продуктивність повинен включати інформацію про інтерпретатор та його версію.
- Щоб уникнути небажаної оптимізації використайте результат виконання алгоритму що досліджується і передайте коректні вхідні аргументи.

[Повернутись до змісту](../README.md#Туторіали)
